{"ast":null,"code":";\n\n(function (sax) {\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream;\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n  var buffers = [\"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\", \"procInstName\", \"procInstBody\", \"entity\", \"attribName\", \"attribValue\", \"cdata\", \"script\"];\n  sax.EVENTS = [\"text\", \"processinginstruction\", \"sgmldeclaration\", \"doctype\", \"comment\", \"attribute\", \"opentag\", \"closetag\", \"opencdata\", \"cdata\", \"closecdata\", \"error\", \"end\", \"ready\", \"script\", \"opennamespace\", \"closenamespace\"];\n\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.ENTITIES = Object.create(sax.ENTITIES);\n    parser.attribList = [];\n    if (parser.opt.xmlns) parser.ns = Object.create(rootNS);\n    parser.trackPosition = parser.opt.position !== false;\n\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0;\n    }\n\n    emit(parser, \"onready\");\n  }\n\n  if (!Object.create) Object.create = function (o) {\n    function f() {\n      this.__proto__ = o;\n    }\n\n    f.prototype = o;\n    return new f();\n  };\n  if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n    return o.__proto__;\n  };\n  if (!Object.keys) Object.keys = function (o) {\n    var a = [];\n\n    for (var i in o) {\n      if (o.hasOwnProperty(i)) a.push(i);\n    }\n\n    return a;\n  };\n\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10),\n        maxActual = 0;\n\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n\n      if (len > maxAllowed) {\n        switch (buffers[i]) {\n          case \"textNode\":\n            closeText(parser);\n            break;\n\n          case \"cdata\":\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n            break;\n\n          case \"script\":\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n            break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n        }\n      }\n\n      maxActual = Math.max(maxActual, len);\n    }\n\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH - maxActual + parser.position;\n  }\n\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = \"\";\n    }\n  }\n\n  function flushBuffers(parser) {\n    closeText(parser);\n\n    if (parser.cdata !== \"\") {\n      emitNode(parser, \"oncdata\", parser.cdata);\n      parser.cdata = \"\";\n    }\n\n    if (parser.script !== \"\") {\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function end() {\n      _end(this);\n    },\n    write: write,\n    resume: function resume() {\n      this.error = null;\n      return this;\n    },\n    close: function close() {\n      return this.write(null);\n    },\n    flush: function flush() {\n      flushBuffers(this);\n    }\n  };\n\n  try {\n    var Stream = require(\"stream\").Stream;\n  } catch (ex) {\n    var Stream = function Stream() {};\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== \"error\" && ev !== \"end\";\n  });\n\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);\n    Stream.apply(this);\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n    var me = this;\n\n    this._parser.onend = function () {\n      me.emit(\"end\");\n    };\n\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n      me._parser.error = null;\n    };\n\n    this._decoder = null;\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev, {\n        get: function get() {\n          return me._parser[\"on\" + ev];\n        },\n        set: function set(h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            return me._parser[\"on\" + ev] = h;\n          }\n\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false\n      });\n    });\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  });\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder;\n\n        this._decoder = new SD('utf8');\n      }\n\n      data = this._decoder.write(data);\n    }\n\n    this._parser.write(data.toString());\n\n    this.emit(\"data\", data);\n    return true;\n  };\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) this.write(chunk);\n\n    this._parser.end();\n\n    return true;\n  };\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n\n    if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\" + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  var whitespace = \"\\r\\n\\t \",\n      number = \"0124356789\",\n      letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n      quote = \"'\\\"\",\n      entity = number + letter + \"#\",\n      attribEnd = whitespace + \">\",\n      CDATA = \"[CDATA[\",\n      DOCTYPE = \"DOCTYPE\",\n      XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\",\n      XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\",\n      rootNS = {\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE\n  };\n  whitespace = charClass(whitespace);\n  number = charClass(number);\n  letter = charClass(letter);\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/;\n  quote = charClass(quote);\n  entity = charClass(entity);\n  attribEnd = charClass(attribEnd);\n\n  function charClass(str) {\n    return str.split(\"\").reduce(function (s, c) {\n      s[c] = true;\n      return s;\n    }, {});\n  }\n\n  function isRegExp(c) {\n    return Object.prototype.toString.call(c) === '[object RegExp]';\n  }\n\n  function is(charclass, c) {\n    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c];\n  }\n\n  function not(charclass, c) {\n    return !is(charclass, c);\n  }\n\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++,\n    TEXT: S++,\n    TEXT_ENTITY: S++,\n    OPEN_WAKA: S++,\n    SGML_DECL: S++,\n    SGML_DECL_QUOTED: S++,\n    DOCTYPE: S++,\n    DOCTYPE_QUOTED: S++,\n    DOCTYPE_DTD: S++,\n    DOCTYPE_DTD_QUOTED: S++,\n    COMMENT_STARTING: S++,\n    COMMENT: S++,\n    COMMENT_ENDING: S++,\n    COMMENT_ENDED: S++,\n    CDATA: S++,\n    CDATA_ENDING: S++,\n    CDATA_ENDING_2: S++,\n    PROC_INST: S++,\n    PROC_INST_BODY: S++,\n    PROC_INST_ENDING: S++,\n    OPEN_TAG: S++,\n    OPEN_TAG_SLASH: S++,\n    ATTRIB: S++,\n    ATTRIB_NAME: S++,\n    ATTRIB_NAME_SAW_WHITE: S++,\n    ATTRIB_VALUE: S++,\n    ATTRIB_VALUE_QUOTED: S++,\n    ATTRIB_VALUE_CLOSED: S++,\n    ATTRIB_VALUE_UNQUOTED: S++,\n    ATTRIB_VALUE_ENTITY_Q: S++,\n    ATTRIB_VALUE_ENTITY_U: S++,\n    CLOSE_TAG: S++,\n    CLOSE_TAG_SAW_WHITE: S++,\n    SCRIPT: S++,\n    SCRIPT_ENDING: S++\n  };\n  sax.ENTITIES = {\n    \"amp\": \"&\",\n    \"gt\": \">\",\n    \"lt\": \"<\",\n    \"quot\": \"\\\"\",\n    \"apos\": \"'\",\n    \"AElig\": 198,\n    \"Aacute\": 193,\n    \"Acirc\": 194,\n    \"Agrave\": 192,\n    \"Aring\": 197,\n    \"Atilde\": 195,\n    \"Auml\": 196,\n    \"Ccedil\": 199,\n    \"ETH\": 208,\n    \"Eacute\": 201,\n    \"Ecirc\": 202,\n    \"Egrave\": 200,\n    \"Euml\": 203,\n    \"Iacute\": 205,\n    \"Icirc\": 206,\n    \"Igrave\": 204,\n    \"Iuml\": 207,\n    \"Ntilde\": 209,\n    \"Oacute\": 211,\n    \"Ocirc\": 212,\n    \"Ograve\": 210,\n    \"Oslash\": 216,\n    \"Otilde\": 213,\n    \"Ouml\": 214,\n    \"THORN\": 222,\n    \"Uacute\": 218,\n    \"Ucirc\": 219,\n    \"Ugrave\": 217,\n    \"Uuml\": 220,\n    \"Yacute\": 221,\n    \"aacute\": 225,\n    \"acirc\": 226,\n    \"aelig\": 230,\n    \"agrave\": 224,\n    \"aring\": 229,\n    \"atilde\": 227,\n    \"auml\": 228,\n    \"ccedil\": 231,\n    \"eacute\": 233,\n    \"ecirc\": 234,\n    \"egrave\": 232,\n    \"eth\": 240,\n    \"euml\": 235,\n    \"iacute\": 237,\n    \"icirc\": 238,\n    \"igrave\": 236,\n    \"iuml\": 239,\n    \"ntilde\": 241,\n    \"oacute\": 243,\n    \"ocirc\": 244,\n    \"ograve\": 242,\n    \"oslash\": 248,\n    \"otilde\": 245,\n    \"ouml\": 246,\n    \"szlig\": 223,\n    \"thorn\": 254,\n    \"uacute\": 250,\n    \"ucirc\": 251,\n    \"ugrave\": 249,\n    \"uuml\": 252,\n    \"yacute\": 253,\n    \"yuml\": 255,\n    \"copy\": 169,\n    \"reg\": 174,\n    \"nbsp\": 160,\n    \"iexcl\": 161,\n    \"cent\": 162,\n    \"pound\": 163,\n    \"curren\": 164,\n    \"yen\": 165,\n    \"brvbar\": 166,\n    \"sect\": 167,\n    \"uml\": 168,\n    \"ordf\": 170,\n    \"laquo\": 171,\n    \"not\": 172,\n    \"shy\": 173,\n    \"macr\": 175,\n    \"deg\": 176,\n    \"plusmn\": 177,\n    \"sup1\": 185,\n    \"sup2\": 178,\n    \"sup3\": 179,\n    \"acute\": 180,\n    \"micro\": 181,\n    \"para\": 182,\n    \"middot\": 183,\n    \"cedil\": 184,\n    \"ordm\": 186,\n    \"raquo\": 187,\n    \"frac14\": 188,\n    \"frac12\": 189,\n    \"frac34\": 190,\n    \"iquest\": 191,\n    \"times\": 215,\n    \"divide\": 247,\n    \"OElig\": 338,\n    \"oelig\": 339,\n    \"Scaron\": 352,\n    \"scaron\": 353,\n    \"Yuml\": 376,\n    \"fnof\": 402,\n    \"circ\": 710,\n    \"tilde\": 732,\n    \"Alpha\": 913,\n    \"Beta\": 914,\n    \"Gamma\": 915,\n    \"Delta\": 916,\n    \"Epsilon\": 917,\n    \"Zeta\": 918,\n    \"Eta\": 919,\n    \"Theta\": 920,\n    \"Iota\": 921,\n    \"Kappa\": 922,\n    \"Lambda\": 923,\n    \"Mu\": 924,\n    \"Nu\": 925,\n    \"Xi\": 926,\n    \"Omicron\": 927,\n    \"Pi\": 928,\n    \"Rho\": 929,\n    \"Sigma\": 931,\n    \"Tau\": 932,\n    \"Upsilon\": 933,\n    \"Phi\": 934,\n    \"Chi\": 935,\n    \"Psi\": 936,\n    \"Omega\": 937,\n    \"alpha\": 945,\n    \"beta\": 946,\n    \"gamma\": 947,\n    \"delta\": 948,\n    \"epsilon\": 949,\n    \"zeta\": 950,\n    \"eta\": 951,\n    \"theta\": 952,\n    \"iota\": 953,\n    \"kappa\": 954,\n    \"lambda\": 955,\n    \"mu\": 956,\n    \"nu\": 957,\n    \"xi\": 958,\n    \"omicron\": 959,\n    \"pi\": 960,\n    \"rho\": 961,\n    \"sigmaf\": 962,\n    \"sigma\": 963,\n    \"tau\": 964,\n    \"upsilon\": 965,\n    \"phi\": 966,\n    \"chi\": 967,\n    \"psi\": 968,\n    \"omega\": 969,\n    \"thetasym\": 977,\n    \"upsih\": 978,\n    \"piv\": 982,\n    \"ensp\": 8194,\n    \"emsp\": 8195,\n    \"thinsp\": 8201,\n    \"zwnj\": 8204,\n    \"zwj\": 8205,\n    \"lrm\": 8206,\n    \"rlm\": 8207,\n    \"ndash\": 8211,\n    \"mdash\": 8212,\n    \"lsquo\": 8216,\n    \"rsquo\": 8217,\n    \"sbquo\": 8218,\n    \"ldquo\": 8220,\n    \"rdquo\": 8221,\n    \"bdquo\": 8222,\n    \"dagger\": 8224,\n    \"Dagger\": 8225,\n    \"bull\": 8226,\n    \"hellip\": 8230,\n    \"permil\": 8240,\n    \"prime\": 8242,\n    \"Prime\": 8243,\n    \"lsaquo\": 8249,\n    \"rsaquo\": 8250,\n    \"oline\": 8254,\n    \"frasl\": 8260,\n    \"euro\": 8364,\n    \"image\": 8465,\n    \"weierp\": 8472,\n    \"real\": 8476,\n    \"trade\": 8482,\n    \"alefsym\": 8501,\n    \"larr\": 8592,\n    \"uarr\": 8593,\n    \"rarr\": 8594,\n    \"darr\": 8595,\n    \"harr\": 8596,\n    \"crarr\": 8629,\n    \"lArr\": 8656,\n    \"uArr\": 8657,\n    \"rArr\": 8658,\n    \"dArr\": 8659,\n    \"hArr\": 8660,\n    \"forall\": 8704,\n    \"part\": 8706,\n    \"exist\": 8707,\n    \"empty\": 8709,\n    \"nabla\": 8711,\n    \"isin\": 8712,\n    \"notin\": 8713,\n    \"ni\": 8715,\n    \"prod\": 8719,\n    \"sum\": 8721,\n    \"minus\": 8722,\n    \"lowast\": 8727,\n    \"radic\": 8730,\n    \"prop\": 8733,\n    \"infin\": 8734,\n    \"ang\": 8736,\n    \"and\": 8743,\n    \"or\": 8744,\n    \"cap\": 8745,\n    \"cup\": 8746,\n    \"int\": 8747,\n    \"there4\": 8756,\n    \"sim\": 8764,\n    \"cong\": 8773,\n    \"asymp\": 8776,\n    \"ne\": 8800,\n    \"equiv\": 8801,\n    \"le\": 8804,\n    \"ge\": 8805,\n    \"sub\": 8834,\n    \"sup\": 8835,\n    \"nsub\": 8836,\n    \"sube\": 8838,\n    \"supe\": 8839,\n    \"oplus\": 8853,\n    \"otimes\": 8855,\n    \"perp\": 8869,\n    \"sdot\": 8901,\n    \"lceil\": 8968,\n    \"rceil\": 8969,\n    \"lfloor\": 8970,\n    \"rfloor\": 8971,\n    \"lang\": 9001,\n    \"rang\": 9002,\n    \"loz\": 9674,\n    \"spades\": 9824,\n    \"clubs\": 9827,\n    \"hearts\": 9829,\n    \"diams\": 9830\n  };\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key];\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e;\n    sax.ENTITIES[key] = s;\n  });\n\n  for (var S in sax.STATE) {\n    sax.STATE[sax.STATE[S]] = S;\n  }\n\n  S = sax.STATE;\n\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n    parser.textNode = \"\";\n  }\n\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error(parser, er) {\n    closeText(parser);\n\n    if (parser.trackPosition) {\n      er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n    }\n\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function _end(parser) {\n    if (!parser.closedRoot) strictFail(parser, \"Unclosed root tag\");\n    if (parser.state !== S.BEGIN && parser.state !== S.TEXT) error(parser, \"Unexpected end\");\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n\n  function strictFail(parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) throw new Error('bad call to strictFail');\n    if (parser.strict) error(parser, message);\n  }\n\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser,\n        tag = parser.tag = {\n      name: parser.tagName,\n      attributes: {}\n    };\n    if (parser.opt.xmlns) tag.ns = parent.ns;\n    parser.attribList.length = 0;\n  }\n\n  function qname(name, attribute) {\n    var i = name.indexOf(\":\"),\n        qualName = i < 0 ? [\"\", name] : name.split(\":\"),\n        prefix = qualName[0],\n        local = qualName[1];\n\n    if (attribute && name === \"xmlns\") {\n      prefix = \"xmlns\";\n      local = \"\";\n    }\n\n    return {\n      prefix: prefix,\n      local: local\n    };\n  }\n\n  function attrib(parser) {\n    if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      return parser.attribName = parser.attribValue = \"\";\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true),\n          prefix = qn.prefix,\n          local = qn.local;\n\n      if (prefix === \"xmlns\") {\n        if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser, \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser, \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else {\n          var tag = parser.tag,\n              parent = parser.tags[parser.tags.length - 1] || parser;\n\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n\n          tag.ns[local] = parser.attribValue;\n        }\n      }\n\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, \"onattribute\", {\n        name: parser.attribName,\n        value: parser.attribValue\n      });\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n  }\n\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      var tag = parser.tag;\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || \"\";\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n        tag.uri = qn.prefix;\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, \"onopennamespace\", {\n            prefix: p,\n            uri: tag.ns[p]\n          });\n        });\n      }\n\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0],\n            value = nv[1],\n            qualName = qname(name, true),\n            prefix = qualName.prefix,\n            local = qualName.local,\n            uri = prefix == \"\" ? \"\" : tag.ns[prefix] || \"\",\n            a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        };\n\n        if (prefix && prefix != \"xmlns\" && !uri) {\n          strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n          a.uri = prefix;\n        }\n\n        parser.tag.attributes[name] = a;\n        emitNode(parser, \"onattribute\", a);\n      }\n\n      parser.attribList.length = 0;\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing;\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n\n    if (!selfClosing) {\n      if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n\n      parser.tag = null;\n      parser.tagName = \"\";\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n  }\n\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, \"Weird empty close tag.\");\n      parser.textNode += \"</>\";\n      parser.state = S.TEXT;\n      return;\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== \"script\") {\n        parser.script += \"</\" + parser.tagName + \">\";\n        parser.tagName = \"\";\n        parser.state = S.SCRIPT;\n        return;\n      }\n\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) tagName = tagName[parser.looseCase]();\n    var closeTo = tagName;\n\n    while (t--) {\n      var close = parser.tags[t];\n\n      if (close.name !== closeTo) {\n        strictFail(parser, \"Unexpected close tag\");\n      } else break;\n    }\n\n    if (t < 0) {\n      strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n      parser.textNode += \"</\" + parser.tagName + \">\";\n      parser.state = S.TEXT;\n      return;\n    }\n\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop();\n      parser.tagName = parser.tag.name;\n      emitNode(parser, \"onclosetag\", parser.tagName);\n      var x = {};\n\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i];\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, \"onclosenamespace\", {\n            prefix: p,\n            uri: n\n          });\n        });\n      }\n    }\n\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n\n  function parseEntity(parser) {\n    var entity = parser.entity,\n        entityLC = entity.toLowerCase(),\n        num,\n        numStr = \"\";\n    if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];\n    if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];\n    entity = entityLC;\n\n    if (entity.charAt(0) === \"#\") {\n      if (entity.charAt(1) === \"x\") {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n\n    entity = entity.replace(/^0+/, \"\");\n\n    if (numStr.toLowerCase() !== entity) {\n      strictFail(parser, \"Invalid character entity\");\n      return \"&\" + parser.entity + \";\";\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n  function write(chunk) {\n    var parser = this;\n    if (this.error) throw this.error;\n    if (parser.closed) return error(parser, \"Cannot write after close. Assign an onready handler.\");\n    if (chunk === null) return _end(parser);\n    var i = 0,\n        c = \"\";\n\n    while (parser.c = c = chunk.charAt(i++)) {\n      if (parser.trackPosition) {\n        parser.position++;\n\n        if (c === \"\\n\") {\n          parser.line++;\n          parser.column = 0;\n        } else parser.column++;\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          if (c === \"<\") {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else if (not(whitespace, c)) {\n            strictFail(parser, \"Non-whitespace before first tag.\");\n            parser.textNode = c;\n            parser.state = S.TEXT;\n          }\n\n          continue;\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n\n            while (c && c !== \"<\" && c !== \"&\") {\n              c = chunk.charAt(i++);\n\n              if (c && parser.trackPosition) {\n                parser.position++;\n\n                if (c === \"\\n\") {\n                  parser.line++;\n                  parser.column = 0;\n                } else parser.column++;\n              }\n            }\n\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n\n          if (c === \"<\") {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else {\n            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, \"Text data outside of root node.\");\n            if (c === \"&\") parser.state = S.TEXT_ENTITY;else parser.textNode += c;\n          }\n\n          continue;\n\n        case S.SCRIPT:\n          if (c === \"<\") {\n            parser.state = S.SCRIPT_ENDING;\n          } else parser.script += c;\n\n          continue;\n\n        case S.SCRIPT_ENDING:\n          if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n          } else {\n            parser.script += \"<\" + c;\n            parser.state = S.SCRIPT;\n          }\n\n          continue;\n\n        case S.OPEN_WAKA:\n          if (c === \"!\") {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = \"\";\n          } else if (is(whitespace, c)) {} else if (is(nameStart, c)) {\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = \"\";\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = \"\";\n          } else {\n            strictFail(parser, \"Unencoded <\");\n\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition;\n              c = new Array(pad).join(\" \") + c;\n            }\n\n            parser.textNode += \"<\" + c;\n            parser.state = S.TEXT;\n          }\n\n          continue;\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, \"onopencdata\");\n            parser.state = S.CDATA;\n            parser.sgmlDecl = \"\";\n            parser.cdata = \"\";\n          } else if (parser.sgmlDecl + c === \"--\") {\n            parser.state = S.COMMENT;\n            parser.comment = \"\";\n            parser.sgmlDecl = \"\";\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n            if (parser.doctype || parser.sawRoot) strictFail(parser, \"Inappropriately located doctype declaration\");\n            parser.doctype = \"\";\n            parser.sgmlDecl = \"\";\n          } else if (c === \">\") {\n            emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n            parser.sgmlDecl = \"\";\n            parser.state = S.TEXT;\n          } else if (is(quote, c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else parser.sgmlDecl += c;\n\n          continue;\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = \"\";\n          }\n\n          parser.sgmlDecl += c;\n          continue;\n\n        case S.DOCTYPE:\n          if (c === \">\") {\n            parser.state = S.TEXT;\n            emitNode(parser, \"ondoctype\", parser.doctype);\n            parser.doctype = true;\n          } else {\n            parser.doctype += c;\n            if (c === \"[\") parser.state = S.DOCTYPE_DTD;else if (is(quote, c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n\n          continue;\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n\n          if (c === parser.q) {\n            parser.q = \"\";\n            parser.state = S.DOCTYPE;\n          }\n\n          continue;\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n          if (c === \"]\") parser.state = S.DOCTYPE;else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = \"\";\n          }\n\n          continue;\n\n        case S.COMMENT:\n          if (c === \"-\") parser.state = S.COMMENT_ENDING;else parser.comment += c;\n          continue;\n\n        case S.COMMENT_ENDING:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n            if (parser.comment) emitNode(parser, \"oncomment\", parser.comment);\n            parser.comment = \"\";\n          } else {\n            parser.comment += \"-\" + c;\n            parser.state = S.COMMENT;\n          }\n\n          continue;\n\n        case S.COMMENT_ENDED:\n          if (c !== \">\") {\n            strictFail(parser, \"Malformed comment\");\n            parser.comment += \"--\" + c;\n            parser.state = S.COMMENT;\n          } else parser.state = S.TEXT;\n\n          continue;\n\n        case S.CDATA:\n          if (c === \"]\") parser.state = S.CDATA_ENDING;else parser.cdata += c;\n          continue;\n\n        case S.CDATA_ENDING:\n          if (c === \"]\") parser.state = S.CDATA_ENDING_2;else {\n            parser.cdata += \"]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.CDATA_ENDING_2:\n          if (c === \">\") {\n            if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata);\n            emitNode(parser, \"onclosecdata\");\n            parser.cdata = \"\";\n            parser.state = S.TEXT;\n          } else if (c === \"]\") {\n            parser.cdata += \"]\";\n          } else {\n            parser.cdata += \"]]\" + c;\n            parser.state = S.CDATA;\n          }\n\n          continue;\n\n        case S.PROC_INST:\n          if (c === \"?\") parser.state = S.PROC_INST_ENDING;else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY;else parser.procInstName += c;\n          continue;\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && is(whitespace, c)) continue;else if (c === \"?\") parser.state = S.PROC_INST_ENDING;else parser.procInstBody += c;\n          continue;\n\n        case S.PROC_INST_ENDING:\n          if (c === \">\") {\n            emitNode(parser, \"onprocessinginstruction\", {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            });\n            parser.procInstName = parser.procInstBody = \"\";\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += \"?\" + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n\n          continue;\n\n        case S.OPEN_TAG:\n          if (is(nameBody, c)) parser.tagName += c;else {\n            newTag(parser);\n            if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else {\n              if (not(whitespace, c)) strictFail(parser, \"Invalid character in tag name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.OPEN_TAG_SLASH:\n          if (c === \">\") {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n            parser.state = S.ATTRIB;\n          }\n\n          continue;\n\n        case S.ATTRIB:\n          if (is(whitespace, c)) continue;else if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else if (is(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else strictFail(parser, \"Invalid attribute name\");\n          continue;\n\n        case S.ATTRIB_NAME:\n          if (c === \"=\") parser.state = S.ATTRIB_VALUE;else if (c === \">\") {\n            strictFail(parser, \"Attribute without value\");\n            parser.attribValue = parser.attribName;\n            attrib(parser);\n            openTag(parser);\n          } else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;else if (is(nameBody, c)) parser.attribName += c;else strictFail(parser, \"Invalid attribute name\");\n          continue;\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === \"=\") parser.state = S.ATTRIB_VALUE;else if (is(whitespace, c)) continue;else {\n            strictFail(parser, \"Attribute without value\");\n            parser.tag.attributes[parser.attribName] = \"\";\n            parser.attribValue = \"\";\n            emitNode(parser, \"onattribute\", {\n              name: parser.attribName,\n              value: \"\"\n            });\n            parser.attribName = \"\";\n            if (c === \">\") openTag(parser);else if (is(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, \"Invalid attribute name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.ATTRIB_VALUE:\n          if (is(whitespace, c)) continue;else if (is(quote, c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, \"Unquoted attribute value\");\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q;else parser.attribValue += c;\n            continue;\n          }\n\n          attrib(parser);\n          parser.q = \"\";\n          parser.state = S.ATTRIB_VALUE_CLOSED;\n          continue;\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (is(whitespace, c)) {\n            parser.state = S.ATTRIB;\n          } else if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else if (is(nameStart, c)) {\n            strictFail(parser, \"No whitespace between attributes\");\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else strictFail(parser, \"Invalid attribute name\");\n\n          continue;\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (not(attribEnd, c)) {\n            if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U;else parser.attribValue += c;\n            continue;\n          }\n\n          attrib(parser);\n          if (c === \">\") openTag(parser);else parser.state = S.ATTRIB;\n          continue;\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (is(whitespace, c)) continue;else if (not(nameStart, c)) {\n              if (parser.script) {\n                parser.script += \"</\" + c;\n                parser.state = S.SCRIPT;\n              } else {\n                strictFail(parser, \"Invalid tagname in closing tag.\");\n              }\n            } else parser.tagName = c;\n          } else if (c === \">\") closeTag(parser);else if (is(nameBody, c)) parser.tagName += c;else if (parser.script) {\n            parser.script += \"</\" + parser.tagName;\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n          } else {\n            if (not(whitespace, c)) strictFail(parser, \"Invalid tagname in closing tag\");\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n\n          continue;\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (is(whitespace, c)) continue;\n          if (c === \">\") closeTag(parser);else strictFail(parser, \"Invalid characters in closing tag\");\n          continue;\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              var returnState = S.TEXT,\n                  buffer = \"textNode\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              var returnState = S.ATTRIB_VALUE_QUOTED,\n                  buffer = \"attribValue\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              var returnState = S.ATTRIB_VALUE_UNQUOTED,\n                  buffer = \"attribValue\";\n              break;\n          }\n\n          if (c === \";\") {\n            parser[buffer] += parseEntity(parser);\n            parser.entity = \"\";\n            parser.state = returnState;\n          } else if (is(entity, c)) parser.entity += c;else {\n            strictFail(parser, \"Invalid character entity\");\n            parser[buffer] += \"&\" + parser.entity + c;\n            parser.entity = \"\";\n            parser.state = returnState;\n          }\n\n          continue;\n\n        default:\n          throw new Error(parser, \"Unknown state: \" + parser.state);\n      }\n    }\n\n    if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);\n    return parser;\n  }\n\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode;\n      var floor = Math.floor;\n\n      var fromCodePoint = function fromCodePoint() {\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = arguments.length;\n\n        if (!length) {\n          return '';\n        }\n\n        var result = '';\n\n        while (++index < length) {\n          var codePoint = Number(arguments[index]);\n\n          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n              throw RangeError('Invalid code point: ' + codePoint);\n            }\n\n          if (codePoint <= 0xFFFF) {\n            codeUnits.push(codePoint);\n          } else {\n            codePoint -= 0x10000;\n            highSurrogate = (codePoint >> 10) + 0xD800;\n            lowSurrogate = codePoint % 0x400 + 0xDC00;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n\n          if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n\n        return result;\n      };\n\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          'value': fromCodePoint,\n          'configurable': true,\n          'writable': true\n        });\n      } else {\n        String.fromCodePoint = fromCodePoint;\n      }\n    })();\n  }\n})(typeof exports === \"undefined\" ? sax = {} : exports);","map":{"version":3,"sources":["/Users/eliothyenne/Daneo/node_modules/react-native-xml2js/node_modules/sax/lib/sax.js"],"names":["sax","parser","strict","opt","SAXParser","SAXStream","createStream","MAX_BUFFER_LENGTH","buffers","EVENTS","clearBuffers","q","c","bufferCheckPosition","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","error","noscript","state","S","BEGIN","ENTITIES","Object","create","attribList","xmlns","ns","rootNS","trackPosition","position","line","column","emit","o","f","__proto__","prototype","getPrototypeOf","keys","a","i","hasOwnProperty","push","checkBufferLength","maxAllowed","Math","max","maxActual","l","length","len","closeText","emitNode","cdata","script","flushBuffers","end","write","resume","close","flush","Stream","require","ex","streamWraps","filter","ev","apply","_parser","writable","readable","me","onend","onerror","er","_decoder","forEach","defineProperty","get","set","h","removeAllListeners","on","enumerable","configurable","constructor","value","data","Buffer","isBuffer","SD","StringDecoder","toString","chunk","handler","indexOf","args","arguments","Array","splice","call","whitespace","number","letter","quote","entity","attribEnd","CDATA","DOCTYPE","XML_NAMESPACE","XMLNS_NAMESPACE","xml","charClass","nameStart","nameBody","str","split","reduce","s","isRegExp","is","charclass","match","not","STATE","TEXT","TEXT_ENTITY","OPEN_WAKA","SGML_DECL","SGML_DECL_QUOTED","DOCTYPE_QUOTED","DOCTYPE_DTD","DOCTYPE_DTD_QUOTED","COMMENT_STARTING","COMMENT","COMMENT_ENDING","COMMENT_ENDED","CDATA_ENDING","CDATA_ENDING_2","PROC_INST","PROC_INST_BODY","PROC_INST_ENDING","OPEN_TAG","OPEN_TAG_SLASH","ATTRIB","ATTRIB_NAME","ATTRIB_NAME_SAW_WHITE","ATTRIB_VALUE","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_CLOSED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG","CLOSE_TAG_SAW_WHITE","SCRIPT","SCRIPT_ENDING","key","e","String","fromCharCode","event","nodeType","textNode","textopts","text","trim","normalize","replace","Error","strictFail","message","newTag","tagName","parent","name","attributes","qname","attribute","qualName","prefix","local","attrib","attribName","attribValue","qn","openTag","selfClosing","uri","JSON","stringify","p","nv","isSelfClosing","toLowerCase","closeTag","t","closeTo","pop","x","n","parseEntity","entityLC","num","numStr","charAt","slice","parseInt","fromCodePoint","startTagPosition","starti","substring","sgmlDecl","procInstName","procInstBody","pad","join","toUpperCase","comment","doctype","body","returnState","buffer","stringFromCharCode","floor","MAX_SIZE","codeUnits","highSurrogate","lowSurrogate","index","result","codePoint","Number","isFinite","RangeError","exports"],"mappings":"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","sourcesContent":["// wrapper for non-node envs\n;(function (sax) {\n\nsax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\nsax.SAXParser = SAXParser\nsax.SAXStream = SAXStream\nsax.createStream = createStream\n\n// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n// since that's the earliest that a buffer overrun could occur.  This way, checks are\n// as rare as required, but as often as necessary to ensure never crossing this bound.\n// Furthermore, buffers are only tested at most once per write(), so passing a very\n// large string into write() might have undesirable effects, but this is manageable by\n// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n// edge case, result in creating at most one complete copy of the string passed in.\n// Set to Infinity to have unlimited buffers.\nsax.MAX_BUFFER_LENGTH = 64 * 1024\n\nvar buffers = [\n  \"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\",\n  \"procInstName\", \"procInstBody\", \"entity\", \"attribName\",\n  \"attribValue\", \"cdata\", \"script\"\n]\n\nsax.EVENTS = // for discoverability.\n  [ \"text\"\n  , \"processinginstruction\"\n  , \"sgmldeclaration\"\n  , \"doctype\"\n  , \"comment\"\n  , \"attribute\"\n  , \"opentag\"\n  , \"closetag\"\n  , \"opencdata\"\n  , \"cdata\"\n  , \"closecdata\"\n  , \"error\"\n  , \"end\"\n  , \"ready\"\n  , \"script\"\n  , \"opennamespace\"\n  , \"closenamespace\"\n  ]\n\nfunction SAXParser (strict, opt) {\n  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)\n\n  var parser = this\n  clearBuffers(parser)\n  parser.q = parser.c = \"\"\n  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n  parser.opt = opt || {}\n  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n  parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\"\n  parser.tags = []\n  parser.closed = parser.closedRoot = parser.sawRoot = false\n  parser.tag = parser.error = null\n  parser.strict = !!strict\n  parser.noscript = !!(strict || parser.opt.noscript)\n  parser.state = S.BEGIN\n  parser.ENTITIES = Object.create(sax.ENTITIES)\n  parser.attribList = []\n\n  // namespaces form a prototype chain.\n  // it always points at the current tag,\n  // which protos to its parent tag.\n  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)\n\n  // mostly just for error reporting\n  parser.trackPosition = parser.opt.position !== false\n  if (parser.trackPosition) {\n    parser.position = parser.line = parser.column = 0\n  }\n  emit(parser, \"onready\")\n}\n\nif (!Object.create) Object.create = function (o) {\n  function f () { this.__proto__ = o }\n  f.prototype = o\n  return new f\n}\n\nif (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n  return o.__proto__\n}\n\nif (!Object.keys) Object.keys = function (o) {\n  var a = []\n  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n  return a\n}\n\nfunction checkBufferLength (parser) {\n  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    , maxActual = 0\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    var len = parser[buffers[i]].length\n    if (len > maxAllowed) {\n      // Text/cdata nodes can get big, and since they're buffered,\n      // we can get here under normal conditions.\n      // Avoid issues by emitting the text node now,\n      // so at least it won't get any bigger.\n      switch (buffers[i]) {\n        case \"textNode\":\n          closeText(parser)\n        break\n\n        case \"cdata\":\n          emitNode(parser, \"oncdata\", parser.cdata)\n          parser.cdata = \"\"\n        break\n\n        case \"script\":\n          emitNode(parser, \"onscript\", parser.script)\n          parser.script = \"\"\n        break\n\n        default:\n          error(parser, \"Max buffer length exceeded: \"+buffers[i])\n      }\n    }\n    maxActual = Math.max(maxActual, len)\n  }\n  // schedule the next check for the earliest possible buffer overrun.\n  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)\n                             + parser.position\n}\n\nfunction clearBuffers (parser) {\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    parser[buffers[i]] = \"\"\n  }\n}\n\nfunction flushBuffers (parser) {\n  closeText(parser)\n  if (parser.cdata !== \"\") {\n    emitNode(parser, \"oncdata\", parser.cdata)\n    parser.cdata = \"\"\n  }\n  if (parser.script !== \"\") {\n    emitNode(parser, \"onscript\", parser.script)\n    parser.script = \"\"\n  }\n}\n\nSAXParser.prototype =\n  { end: function () { end(this) }\n  , write: write\n  , resume: function () { this.error = null; return this }\n  , close: function () { return this.write(null) }\n  , flush: function () { flushBuffers(this) }\n  }\n\ntry {\n  var Stream = require(\"stream\").Stream\n} catch (ex) {\n  var Stream = function () {}\n}\n\n\nvar streamWraps = sax.EVENTS.filter(function (ev) {\n  return ev !== \"error\" && ev !== \"end\"\n})\n\nfunction createStream (strict, opt) {\n  return new SAXStream(strict, opt)\n}\n\nfunction SAXStream (strict, opt) {\n  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)\n\n  Stream.apply(this)\n\n  this._parser = new SAXParser(strict, opt)\n  this.writable = true\n  this.readable = true\n\n\n  var me = this\n\n  this._parser.onend = function () {\n    me.emit(\"end\")\n  }\n\n  this._parser.onerror = function (er) {\n    me.emit(\"error\", er)\n\n    // if didn't throw, then means error was handled.\n    // go ahead and clear error, so we can write again.\n    me._parser.error = null\n  }\n\n  this._decoder = null;\n\n  streamWraps.forEach(function (ev) {\n    Object.defineProperty(me, \"on\" + ev, {\n      get: function () { return me._parser[\"on\" + ev] },\n      set: function (h) {\n        if (!h) {\n          me.removeAllListeners(ev)\n          return me._parser[\"on\"+ev] = h\n        }\n        me.on(ev, h)\n      },\n      enumerable: true,\n      configurable: false\n    })\n  })\n}\n\nSAXStream.prototype = Object.create(Stream.prototype,\n  { constructor: { value: SAXStream } })\n\nSAXStream.prototype.write = function (data) {\n  if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n    if (!this._decoder) {\n      var SD = require('string_decoder').StringDecoder\n      this._decoder = new SD('utf8')\n    }\n    data = this._decoder.write(data);\n  }\n\n  this._parser.write(data.toString())\n  this.emit(\"data\", data)\n  return true\n}\n\nSAXStream.prototype.end = function (chunk) {\n  if (chunk && chunk.length) this.write(chunk)\n  this._parser.end()\n  return true\n}\n\nSAXStream.prototype.on = function (ev, handler) {\n  var me = this\n  if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n    me._parser[\"on\"+ev] = function () {\n      var args = arguments.length === 1 ? [arguments[0]]\n               : Array.apply(null, arguments)\n      args.splice(0, 0, ev)\n      me.emit.apply(me, args)\n    }\n  }\n\n  return Stream.prototype.on.call(me, ev, handler)\n}\n\n\n\n// character classes and tokens\nvar whitespace = \"\\r\\n\\t \"\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  , number = \"0124356789\"\n  , letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  // (Letter | \"_\" | \":\")\n  , quote = \"'\\\"\"\n  , entity = number+letter+\"#\"\n  , attribEnd = whitespace + \">\"\n  , CDATA = \"[CDATA[\"\n  , DOCTYPE = \"DOCTYPE\"\n  , XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\"\n  , XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\"\n  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n// turn all the string character sets into character class objects.\nwhitespace = charClass(whitespace)\nnumber = charClass(number)\nletter = charClass(letter)\n\n// http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n// This implementation works on strings, a single character at a time\n// as such, it cannot ever support astral-plane characters (10000-EFFFF)\n// without a significant breaking change to either this  parser, or the\n// JavaScript language.  Implementation of an emoji-capable xml parser\n// is left as an exercise for the reader.\nvar nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\nvar nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\nquote = charClass(quote)\nentity = charClass(entity)\nattribEnd = charClass(attribEnd)\n\nfunction charClass (str) {\n  return str.split(\"\").reduce(function (s, c) {\n    s[c] = true\n    return s\n  }, {})\n}\n\nfunction isRegExp (c) {\n  return Object.prototype.toString.call(c) === '[object RegExp]'\n}\n\nfunction is (charclass, c) {\n  return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]\n}\n\nfunction not (charclass, c) {\n  return !is(charclass, c)\n}\n\nvar S = 0\nsax.STATE =\n{ BEGIN                     : S++\n, TEXT                      : S++ // general stuff\n, TEXT_ENTITY               : S++ // &amp and such.\n, OPEN_WAKA                 : S++ // <\n, SGML_DECL                 : S++ // <!BLARG\n, SGML_DECL_QUOTED          : S++ // <!BLARG foo \"bar\n, DOCTYPE                   : S++ // <!DOCTYPE\n, DOCTYPE_QUOTED            : S++ // <!DOCTYPE \"//blah\n, DOCTYPE_DTD               : S++ // <!DOCTYPE \"//blah\" [ ...\n, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE \"//blah\" [ \"foo\n, COMMENT_STARTING          : S++ // <!-\n, COMMENT                   : S++ // <!--\n, COMMENT_ENDING            : S++ // <!-- blah -\n, COMMENT_ENDED             : S++ // <!-- blah --\n, CDATA                     : S++ // <![CDATA[ something\n, CDATA_ENDING              : S++ // ]\n, CDATA_ENDING_2            : S++ // ]]\n, PROC_INST                 : S++ // <?hi\n, PROC_INST_BODY            : S++ // <?hi there\n, PROC_INST_ENDING          : S++ // <?hi \"there\" ?\n, OPEN_TAG                  : S++ // <strong\n, OPEN_TAG_SLASH            : S++ // <strong /\n, ATTRIB                    : S++ // <a\n, ATTRIB_NAME               : S++ // <a foo\n, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _\n, ATTRIB_VALUE              : S++ // <a foo=\n, ATTRIB_VALUE_QUOTED       : S++ // <a foo=\"bar\n, ATTRIB_VALUE_CLOSED       : S++ // <a foo=\"bar\"\n, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar\n, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar=\"&quot;\"\n, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;\n, CLOSE_TAG                 : S++ // </a\n, CLOSE_TAG_SAW_WHITE       : S++ // </a   >\n, SCRIPT                    : S++ // <script> ...\n, SCRIPT_ENDING             : S++ // <script> ... <\n}\n\nsax.ENTITIES =\n{ \"amp\" : \"&\"\n, \"gt\" : \">\"\n, \"lt\" : \"<\"\n, \"quot\" : \"\\\"\"\n, \"apos\" : \"'\"\n, \"AElig\" : 198\n, \"Aacute\" : 193\n, \"Acirc\" : 194\n, \"Agrave\" : 192\n, \"Aring\" : 197\n, \"Atilde\" : 195\n, \"Auml\" : 196\n, \"Ccedil\" : 199\n, \"ETH\" : 208\n, \"Eacute\" : 201\n, \"Ecirc\" : 202\n, \"Egrave\" : 200\n, \"Euml\" : 203\n, \"Iacute\" : 205\n, \"Icirc\" : 206\n, \"Igrave\" : 204\n, \"Iuml\" : 207\n, \"Ntilde\" : 209\n, \"Oacute\" : 211\n, \"Ocirc\" : 212\n, \"Ograve\" : 210\n, \"Oslash\" : 216\n, \"Otilde\" : 213\n, \"Ouml\" : 214\n, \"THORN\" : 222\n, \"Uacute\" : 218\n, \"Ucirc\" : 219\n, \"Ugrave\" : 217\n, \"Uuml\" : 220\n, \"Yacute\" : 221\n, \"aacute\" : 225\n, \"acirc\" : 226\n, \"aelig\" : 230\n, \"agrave\" : 224\n, \"aring\" : 229\n, \"atilde\" : 227\n, \"auml\" : 228\n, \"ccedil\" : 231\n, \"eacute\" : 233\n, \"ecirc\" : 234\n, \"egrave\" : 232\n, \"eth\" : 240\n, \"euml\" : 235\n, \"iacute\" : 237\n, \"icirc\" : 238\n, \"igrave\" : 236\n, \"iuml\" : 239\n, \"ntilde\" : 241\n, \"oacute\" : 243\n, \"ocirc\" : 244\n, \"ograve\" : 242\n, \"oslash\" : 248\n, \"otilde\" : 245\n, \"ouml\" : 246\n, \"szlig\" : 223\n, \"thorn\" : 254\n, \"uacute\" : 250\n, \"ucirc\" : 251\n, \"ugrave\" : 249\n, \"uuml\" : 252\n, \"yacute\" : 253\n, \"yuml\" : 255\n, \"copy\" : 169\n, \"reg\" : 174\n, \"nbsp\" : 160\n, \"iexcl\" : 161\n, \"cent\" : 162\n, \"pound\" : 163\n, \"curren\" : 164\n, \"yen\" : 165\n, \"brvbar\" : 166\n, \"sect\" : 167\n, \"uml\" : 168\n, \"ordf\" : 170\n, \"laquo\" : 171\n, \"not\" : 172\n, \"shy\" : 173\n, \"macr\" : 175\n, \"deg\" : 176\n, \"plusmn\" : 177\n, \"sup1\" : 185\n, \"sup2\" : 178\n, \"sup3\" : 179\n, \"acute\" : 180\n, \"micro\" : 181\n, \"para\" : 182\n, \"middot\" : 183\n, \"cedil\" : 184\n, \"ordm\" : 186\n, \"raquo\" : 187\n, \"frac14\" : 188\n, \"frac12\" : 189\n, \"frac34\" : 190\n, \"iquest\" : 191\n, \"times\" : 215\n, \"divide\" : 247\n, \"OElig\" : 338\n, \"oelig\" : 339\n, \"Scaron\" : 352\n, \"scaron\" : 353\n, \"Yuml\" : 376\n, \"fnof\" : 402\n, \"circ\" : 710\n, \"tilde\" : 732\n, \"Alpha\" : 913\n, \"Beta\" : 914\n, \"Gamma\" : 915\n, \"Delta\" : 916\n, \"Epsilon\" : 917\n, \"Zeta\" : 918\n, \"Eta\" : 919\n, \"Theta\" : 920\n, \"Iota\" : 921\n, \"Kappa\" : 922\n, \"Lambda\" : 923\n, \"Mu\" : 924\n, \"Nu\" : 925\n, \"Xi\" : 926\n, \"Omicron\" : 927\n, \"Pi\" : 928\n, \"Rho\" : 929\n, \"Sigma\" : 931\n, \"Tau\" : 932\n, \"Upsilon\" : 933\n, \"Phi\" : 934\n, \"Chi\" : 935\n, \"Psi\" : 936\n, \"Omega\" : 937\n, \"alpha\" : 945\n, \"beta\" : 946\n, \"gamma\" : 947\n, \"delta\" : 948\n, \"epsilon\" : 949\n, \"zeta\" : 950\n, \"eta\" : 951\n, \"theta\" : 952\n, \"iota\" : 953\n, \"kappa\" : 954\n, \"lambda\" : 955\n, \"mu\" : 956\n, \"nu\" : 957\n, \"xi\" : 958\n, \"omicron\" : 959\n, \"pi\" : 960\n, \"rho\" : 961\n, \"sigmaf\" : 962\n, \"sigma\" : 963\n, \"tau\" : 964\n, \"upsilon\" : 965\n, \"phi\" : 966\n, \"chi\" : 967\n, \"psi\" : 968\n, \"omega\" : 969\n, \"thetasym\" : 977\n, \"upsih\" : 978\n, \"piv\" : 982\n, \"ensp\" : 8194\n, \"emsp\" : 8195\n, \"thinsp\" : 8201\n, \"zwnj\" : 8204\n, \"zwj\" : 8205\n, \"lrm\" : 8206\n, \"rlm\" : 8207\n, \"ndash\" : 8211\n, \"mdash\" : 8212\n, \"lsquo\" : 8216\n, \"rsquo\" : 8217\n, \"sbquo\" : 8218\n, \"ldquo\" : 8220\n, \"rdquo\" : 8221\n, \"bdquo\" : 8222\n, \"dagger\" : 8224\n, \"Dagger\" : 8225\n, \"bull\" : 8226\n, \"hellip\" : 8230\n, \"permil\" : 8240\n, \"prime\" : 8242\n, \"Prime\" : 8243\n, \"lsaquo\" : 8249\n, \"rsaquo\" : 8250\n, \"oline\" : 8254\n, \"frasl\" : 8260\n, \"euro\" : 8364\n, \"image\" : 8465\n, \"weierp\" : 8472\n, \"real\" : 8476\n, \"trade\" : 8482\n, \"alefsym\" : 8501\n, \"larr\" : 8592\n, \"uarr\" : 8593\n, \"rarr\" : 8594\n, \"darr\" : 8595\n, \"harr\" : 8596\n, \"crarr\" : 8629\n, \"lArr\" : 8656\n, \"uArr\" : 8657\n, \"rArr\" : 8658\n, \"dArr\" : 8659\n, \"hArr\" : 8660\n, \"forall\" : 8704\n, \"part\" : 8706\n, \"exist\" : 8707\n, \"empty\" : 8709\n, \"nabla\" : 8711\n, \"isin\" : 8712\n, \"notin\" : 8713\n, \"ni\" : 8715\n, \"prod\" : 8719\n, \"sum\" : 8721\n, \"minus\" : 8722\n, \"lowast\" : 8727\n, \"radic\" : 8730\n, \"prop\" : 8733\n, \"infin\" : 8734\n, \"ang\" : 8736\n, \"and\" : 8743\n, \"or\" : 8744\n, \"cap\" : 8745\n, \"cup\" : 8746\n, \"int\" : 8747\n, \"there4\" : 8756\n, \"sim\" : 8764\n, \"cong\" : 8773\n, \"asymp\" : 8776\n, \"ne\" : 8800\n, \"equiv\" : 8801\n, \"le\" : 8804\n, \"ge\" : 8805\n, \"sub\" : 8834\n, \"sup\" : 8835\n, \"nsub\" : 8836\n, \"sube\" : 8838\n, \"supe\" : 8839\n, \"oplus\" : 8853\n, \"otimes\" : 8855\n, \"perp\" : 8869\n, \"sdot\" : 8901\n, \"lceil\" : 8968\n, \"rceil\" : 8969\n, \"lfloor\" : 8970\n, \"rfloor\" : 8971\n, \"lang\" : 9001\n, \"rang\" : 9002\n, \"loz\" : 9674\n, \"spades\" : 9824\n, \"clubs\" : 9827\n, \"hearts\" : 9829\n, \"diams\" : 9830\n}\n\nObject.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n})\n\nfor (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S\n\n// shorthand\nS = sax.STATE\n\nfunction emit (parser, event, data) {\n  parser[event] && parser[event](data)\n}\n\nfunction emitNode (parser, nodeType, data) {\n  if (parser.textNode) closeText(parser)\n  emit(parser, nodeType, data)\n}\n\nfunction closeText (parser) {\n  parser.textNode = textopts(parser.opt, parser.textNode)\n  if (parser.textNode) emit(parser, \"ontext\", parser.textNode)\n  parser.textNode = \"\"\n}\n\nfunction textopts (opt, text) {\n  if (opt.trim) text = text.trim()\n  if (opt.normalize) text = text.replace(/\\s+/g, \" \")\n  return text\n}\n\nfunction error (parser, er) {\n  closeText(parser)\n  if (parser.trackPosition) {\n    er += \"\\nLine: \"+parser.line+\n          \"\\nColumn: \"+parser.column+\n          \"\\nChar: \"+parser.c\n  }\n  er = new Error(er)\n  parser.error = er\n  emit(parser, \"onerror\", er)\n  return parser\n}\n\nfunction end (parser) {\n  if (!parser.closedRoot) strictFail(parser, \"Unclosed root tag\")\n  if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, \"Unexpected end\")\n  closeText(parser)\n  parser.c = \"\"\n  parser.closed = true\n  emit(parser, \"onend\")\n  SAXParser.call(parser, parser.strict, parser.opt)\n  return parser\n}\n\nfunction strictFail (parser, message) {\n  if (typeof parser !== 'object' || !(parser instanceof SAXParser))\n    throw new Error('bad call to strictFail');\n  if (parser.strict) error(parser, message)\n}\n\nfunction newTag (parser) {\n  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n  var parent = parser.tags[parser.tags.length - 1] || parser\n    , tag = parser.tag = { name : parser.tagName, attributes : {} }\n\n  // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n  if (parser.opt.xmlns) tag.ns = parent.ns\n  parser.attribList.length = 0\n}\n\nfunction qname (name, attribute) {\n  var i = name.indexOf(\":\")\n    , qualName = i < 0 ? [ \"\", name ] : name.split(\":\")\n    , prefix = qualName[0]\n    , local = qualName[1]\n\n  // <x \"xmlns\"=\"http://foo\">\n  if (attribute && name === \"xmlns\") {\n    prefix = \"xmlns\"\n    local = \"\"\n  }\n\n  return { prefix: prefix, local: local }\n}\n\nfunction attrib (parser) {\n  if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()\n\n  if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n    return parser.attribName = parser.attribValue = \"\"\n  }\n\n  if (parser.opt.xmlns) {\n    var qn = qname(parser.attribName, true)\n      , prefix = qn.prefix\n      , local = qn.local\n\n    if (prefix === \"xmlns\") {\n      // namespace binding attribute; push the binding into scope\n      if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n        strictFail( parser\n                  , \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n        strictFail( parser\n                  , \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else {\n        var tag = parser.tag\n          , parent = parser.tags[parser.tags.length - 1] || parser\n        if (tag.ns === parent.ns) {\n          tag.ns = Object.create(parent.ns)\n        }\n        tag.ns[local] = parser.attribValue\n      }\n    }\n\n    // defer onattribute events until all attributes have been seen\n    // so any new bindings can take effect; preserve attribute order\n    // so deferred events can be emitted in document order\n    parser.attribList.push([parser.attribName, parser.attribValue])\n  } else {\n    // in non-xmlns mode, we can emit the event right away\n    parser.tag.attributes[parser.attribName] = parser.attribValue\n    emitNode( parser\n            , \"onattribute\"\n            , { name: parser.attribName\n              , value: parser.attribValue } )\n  }\n\n  parser.attribName = parser.attribValue = \"\"\n}\n\nfunction openTag (parser, selfClosing) {\n  if (parser.opt.xmlns) {\n    // emit namespace binding events\n    var tag = parser.tag\n\n    // add namespace info to tag\n    var qn = qname(parser.tagName)\n    tag.prefix = qn.prefix\n    tag.local = qn.local\n    tag.uri = tag.ns[qn.prefix] || \"\"\n\n    if (tag.prefix && !tag.uri) {\n      strictFail(parser, \"Unbound namespace prefix: \"\n                       + JSON.stringify(parser.tagName))\n      tag.uri = qn.prefix\n    }\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (tag.ns && parent.ns !== tag.ns) {\n      Object.keys(tag.ns).forEach(function (p) {\n        emitNode( parser\n                , \"onopennamespace\"\n                , { prefix: p , uri: tag.ns[p] } )\n      })\n    }\n\n    // handle deferred onattribute events\n    // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n    for (var i = 0, l = parser.attribList.length; i < l; i ++) {\n      var nv = parser.attribList[i]\n      var name = nv[0]\n        , value = nv[1]\n        , qualName = qname(name, true)\n        , prefix = qualName.prefix\n        , local = qualName.local\n        , uri = prefix == \"\" ? \"\" : (tag.ns[prefix] || \"\")\n        , a = { name: name\n              , value: value\n              , prefix: prefix\n              , local: local\n              , uri: uri\n              }\n\n      // if there's any attributes with an undefined namespace,\n      // then fail on them now.\n      if (prefix && prefix != \"xmlns\" && !uri) {\n        strictFail(parser, \"Unbound namespace prefix: \"\n                         + JSON.stringify(prefix))\n        a.uri = prefix\n      }\n      parser.tag.attributes[name] = a\n      emitNode(parser, \"onattribute\", a)\n    }\n    parser.attribList.length = 0\n  }\n\n  parser.tag.isSelfClosing = !!selfClosing\n\n  // process the tag\n  parser.sawRoot = true\n  parser.tags.push(parser.tag)\n  emitNode(parser, \"onopentag\", parser.tag)\n  if (!selfClosing) {\n    // special case for <script> in non-strict mode.\n    if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n      parser.state = S.SCRIPT\n    } else {\n      parser.state = S.TEXT\n    }\n    parser.tag = null\n    parser.tagName = \"\"\n  }\n  parser.attribName = parser.attribValue = \"\"\n  parser.attribList.length = 0\n}\n\nfunction closeTag (parser) {\n  if (!parser.tagName) {\n    strictFail(parser, \"Weird empty close tag.\")\n    parser.textNode += \"</>\"\n    parser.state = S.TEXT\n    return\n  }\n\n  if (parser.script) {\n    if (parser.tagName !== \"script\") {\n      parser.script += \"</\" + parser.tagName + \">\"\n      parser.tagName = \"\"\n      parser.state = S.SCRIPT\n      return\n    }\n    emitNode(parser, \"onscript\", parser.script)\n    parser.script = \"\"\n  }\n\n  // first make sure that the closing tag actually exists.\n  // <a><b></c></b></a> will close everything, otherwise.\n  var t = parser.tags.length\n  var tagName = parser.tagName\n  if (!parser.strict) tagName = tagName[parser.looseCase]()\n  var closeTo = tagName\n  while (t --) {\n    var close = parser.tags[t]\n    if (close.name !== closeTo) {\n      // fail the first time in strict mode\n      strictFail(parser, \"Unexpected close tag\")\n    } else break\n  }\n\n  // didn't find it.  we already failed for strict, so just abort.\n  if (t < 0) {\n    strictFail(parser, \"Unmatched closing tag: \"+parser.tagName)\n    parser.textNode += \"</\" + parser.tagName + \">\"\n    parser.state = S.TEXT\n    return\n  }\n  parser.tagName = tagName\n  var s = parser.tags.length\n  while (s --> t) {\n    var tag = parser.tag = parser.tags.pop()\n    parser.tagName = parser.tag.name\n    emitNode(parser, \"onclosetag\", parser.tagName)\n\n    var x = {}\n    for (var i in tag.ns) x[i] = tag.ns[i]\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (parser.opt.xmlns && tag.ns !== parent.ns) {\n      // remove namespace bindings introduced by tag\n      Object.keys(tag.ns).forEach(function (p) {\n        var n = tag.ns[p]\n        emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n })\n      })\n    }\n  }\n  if (t === 0) parser.closedRoot = true\n  parser.tagName = parser.attribValue = parser.attribName = \"\"\n  parser.attribList.length = 0\n  parser.state = S.TEXT\n}\n\nfunction parseEntity (parser) {\n  var entity = parser.entity\n    , entityLC = entity.toLowerCase()\n    , num\n    , numStr = \"\"\n  if (parser.ENTITIES[entity])\n    return parser.ENTITIES[entity]\n  if (parser.ENTITIES[entityLC])\n    return parser.ENTITIES[entityLC]\n  entity = entityLC\n  if (entity.charAt(0) === \"#\") {\n    if (entity.charAt(1) === \"x\") {\n      entity = entity.slice(2)\n      num = parseInt(entity, 16)\n      numStr = num.toString(16)\n    } else {\n      entity = entity.slice(1)\n      num = parseInt(entity, 10)\n      numStr = num.toString(10)\n    }\n  }\n  entity = entity.replace(/^0+/, \"\")\n  if (numStr.toLowerCase() !== entity) {\n    strictFail(parser, \"Invalid character entity\")\n    return \"&\"+parser.entity + \";\"\n  }\n\n  return String.fromCodePoint(num)\n}\n\nfunction write (chunk) {\n  var parser = this\n  if (this.error) throw this.error\n  if (parser.closed) return error(parser,\n    \"Cannot write after close. Assign an onready handler.\")\n  if (chunk === null) return end(parser)\n  var i = 0, c = \"\"\n  while (parser.c = c = chunk.charAt(i++)) {\n    if (parser.trackPosition) {\n      parser.position ++\n      if (c === \"\\n\") {\n        parser.line ++\n        parser.column = 0\n      } else parser.column ++\n    }\n    switch (parser.state) {\n\n      case S.BEGIN:\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA\n          parser.startTagPosition = parser.position\n        } else if (not(whitespace,c)) {\n          // have to process this as a text node.\n          // weird, but happens.\n          strictFail(parser, \"Non-whitespace before first tag.\")\n          parser.textNode = c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.TEXT:\n        if (parser.sawRoot && !parser.closedRoot) {\n          var starti = i-1\n          while (c && c!==\"<\" && c!==\"&\") {\n            c = chunk.charAt(i++)\n            if (c && parser.trackPosition) {\n              parser.position ++\n              if (c === \"\\n\") {\n                parser.line ++\n                parser.column = 0\n              } else parser.column ++\n            }\n          }\n          parser.textNode += chunk.substring(starti, i-1)\n        }\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA\n          parser.startTagPosition = parser.position\n        } else {\n          if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))\n            strictFail(parser, \"Text data outside of root node.\")\n          if (c === \"&\") parser.state = S.TEXT_ENTITY\n          else parser.textNode += c\n        }\n      continue\n\n      case S.SCRIPT:\n        // only non-strict\n        if (c === \"<\") {\n          parser.state = S.SCRIPT_ENDING\n        } else parser.script += c\n      continue\n\n      case S.SCRIPT_ENDING:\n        if (c === \"/\") {\n          parser.state = S.CLOSE_TAG\n        } else {\n          parser.script += \"<\" + c\n          parser.state = S.SCRIPT\n        }\n      continue\n\n      case S.OPEN_WAKA:\n        // either a /, ?, !, or text is coming next.\n        if (c === \"!\") {\n          parser.state = S.SGML_DECL\n          parser.sgmlDecl = \"\"\n        } else if (is(whitespace, c)) {\n          // wait for it...\n        } else if (is(nameStart,c)) {\n          parser.state = S.OPEN_TAG\n          parser.tagName = c\n        } else if (c === \"/\") {\n          parser.state = S.CLOSE_TAG\n          parser.tagName = \"\"\n        } else if (c === \"?\") {\n          parser.state = S.PROC_INST\n          parser.procInstName = parser.procInstBody = \"\"\n        } else {\n          strictFail(parser, \"Unencoded <\")\n          // if there was some whitespace, then add that in.\n          if (parser.startTagPosition + 1 < parser.position) {\n            var pad = parser.position - parser.startTagPosition\n            c = new Array(pad).join(\" \") + c\n          }\n          parser.textNode += \"<\" + c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.SGML_DECL:\n        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {\n          emitNode(parser, \"onopencdata\")\n          parser.state = S.CDATA\n          parser.sgmlDecl = \"\"\n          parser.cdata = \"\"\n        } else if (parser.sgmlDecl+c === \"--\") {\n          parser.state = S.COMMENT\n          parser.comment = \"\"\n          parser.sgmlDecl = \"\"\n        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {\n          parser.state = S.DOCTYPE\n          if (parser.doctype || parser.sawRoot) strictFail(parser,\n            \"Inappropriately located doctype declaration\")\n          parser.doctype = \"\"\n          parser.sgmlDecl = \"\"\n        } else if (c === \">\") {\n          emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl)\n          parser.sgmlDecl = \"\"\n          parser.state = S.TEXT\n        } else if (is(quote, c)) {\n          parser.state = S.SGML_DECL_QUOTED\n          parser.sgmlDecl += c\n        } else parser.sgmlDecl += c\n      continue\n\n      case S.SGML_DECL_QUOTED:\n        if (c === parser.q) {\n          parser.state = S.SGML_DECL\n          parser.q = \"\"\n        }\n        parser.sgmlDecl += c\n      continue\n\n      case S.DOCTYPE:\n        if (c === \">\") {\n          parser.state = S.TEXT\n          emitNode(parser, \"ondoctype\", parser.doctype)\n          parser.doctype = true // just remember that we saw it.\n        } else {\n          parser.doctype += c\n          if (c === \"[\") parser.state = S.DOCTYPE_DTD\n          else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_QUOTED\n            parser.q = c\n          }\n        }\n      continue\n\n      case S.DOCTYPE_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.q = \"\"\n          parser.state = S.DOCTYPE\n        }\n      continue\n\n      case S.DOCTYPE_DTD:\n        parser.doctype += c\n        if (c === \"]\") parser.state = S.DOCTYPE\n        else if (is(quote,c)) {\n          parser.state = S.DOCTYPE_DTD_QUOTED\n          parser.q = c\n        }\n      continue\n\n      case S.DOCTYPE_DTD_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.state = S.DOCTYPE_DTD\n          parser.q = \"\"\n        }\n      continue\n\n      case S.COMMENT:\n        if (c === \"-\") parser.state = S.COMMENT_ENDING\n        else parser.comment += c\n      continue\n\n      case S.COMMENT_ENDING:\n        if (c === \"-\") {\n          parser.state = S.COMMENT_ENDED\n          parser.comment = textopts(parser.opt, parser.comment)\n          if (parser.comment) emitNode(parser, \"oncomment\", parser.comment)\n          parser.comment = \"\"\n        } else {\n          parser.comment += \"-\" + c\n          parser.state = S.COMMENT\n        }\n      continue\n\n      case S.COMMENT_ENDED:\n        if (c !== \">\") {\n          strictFail(parser, \"Malformed comment\")\n          // allow <!-- blah -- bloo --> in non-strict mode,\n          // which is a comment of \" blah -- bloo \"\n          parser.comment += \"--\" + c\n          parser.state = S.COMMENT\n        } else parser.state = S.TEXT\n      continue\n\n      case S.CDATA:\n        if (c === \"]\") parser.state = S.CDATA_ENDING\n        else parser.cdata += c\n      continue\n\n      case S.CDATA_ENDING:\n        if (c === \"]\") parser.state = S.CDATA_ENDING_2\n        else {\n          parser.cdata += \"]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.CDATA_ENDING_2:\n        if (c === \">\") {\n          if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata)\n          emitNode(parser, \"onclosecdata\")\n          parser.cdata = \"\"\n          parser.state = S.TEXT\n        } else if (c === \"]\") {\n          parser.cdata += \"]\"\n        } else {\n          parser.cdata += \"]]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.PROC_INST:\n        if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY\n        else parser.procInstName += c\n      continue\n\n      case S.PROC_INST_BODY:\n        if (!parser.procInstBody && is(whitespace, c)) continue\n        else if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else parser.procInstBody += c\n      continue\n\n      case S.PROC_INST_ENDING:\n        if (c === \">\") {\n          emitNode(parser, \"onprocessinginstruction\", {\n            name : parser.procInstName,\n            body : parser.procInstBody\n          })\n          parser.procInstName = parser.procInstBody = \"\"\n          parser.state = S.TEXT\n        } else {\n          parser.procInstBody += \"?\" + c\n          parser.state = S.PROC_INST_BODY\n        }\n      continue\n\n      case S.OPEN_TAG:\n        if (is(nameBody, c)) parser.tagName += c\n        else {\n          newTag(parser)\n          if (c === \">\") openTag(parser)\n          else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n          else {\n            if (not(whitespace, c)) strictFail(\n              parser, \"Invalid character in tag name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.OPEN_TAG_SLASH:\n        if (c === \">\") {\n          openTag(parser, true)\n          closeTag(parser)\n        } else {\n          strictFail(parser, \"Forward-slash in opening tag not followed by >\")\n          parser.state = S.ATTRIB\n        }\n      continue\n\n      case S.ATTRIB:\n        // haven't read the attribute name yet.\n        if (is(whitespace, c)) continue\n        else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (c === \">\") {\n          strictFail(parser, \"Attribute without value\")\n          parser.attribValue = parser.attribName\n          attrib(parser)\n          openTag(parser)\n        }\n        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE\n        else if (is(nameBody, c)) parser.attribName += c\n        else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME_SAW_WHITE:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (is(whitespace, c)) continue\n        else {\n          strictFail(parser, \"Attribute without value\")\n          parser.tag.attributes[parser.attribName] = \"\"\n          parser.attribValue = \"\"\n          emitNode(parser, \"onattribute\",\n                   { name : parser.attribName, value : \"\" })\n          parser.attribName = \"\"\n          if (c === \">\") openTag(parser)\n          else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, \"Invalid attribute name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.ATTRIB_VALUE:\n        if (is(whitespace, c)) continue\n        else if (is(quote, c)) {\n          parser.q = c\n          parser.state = S.ATTRIB_VALUE_QUOTED\n        } else {\n          strictFail(parser, \"Unquoted attribute value\")\n          parser.state = S.ATTRIB_VALUE_UNQUOTED\n          parser.attribValue = c\n        }\n      continue\n\n      case S.ATTRIB_VALUE_QUOTED:\n        if (c !== parser.q) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        parser.q = \"\"\n        parser.state = S.ATTRIB_VALUE_CLOSED\n      continue\n\n      case S.ATTRIB_VALUE_CLOSED:\n        if (is(whitespace, c)) {\n          parser.state = S.ATTRIB\n        } else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          strictFail(parser, \"No whitespace between attributes\")\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_VALUE_UNQUOTED:\n        if (not(attribEnd,c)) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        if (c === \">\") openTag(parser)\n        else parser.state = S.ATTRIB\n      continue\n\n      case S.CLOSE_TAG:\n        if (!parser.tagName) {\n          if (is(whitespace, c)) continue\n          else if (not(nameStart, c)) {\n            if (parser.script) {\n              parser.script += \"</\" + c\n              parser.state = S.SCRIPT\n            } else {\n              strictFail(parser, \"Invalid tagname in closing tag.\")\n            }\n          } else parser.tagName = c\n        }\n        else if (c === \">\") closeTag(parser)\n        else if (is(nameBody, c)) parser.tagName += c\n        else if (parser.script) {\n          parser.script += \"</\" + parser.tagName\n          parser.tagName = \"\"\n          parser.state = S.SCRIPT\n        } else {\n          if (not(whitespace, c)) strictFail(parser,\n            \"Invalid tagname in closing tag\")\n          parser.state = S.CLOSE_TAG_SAW_WHITE\n        }\n      continue\n\n      case S.CLOSE_TAG_SAW_WHITE:\n        if (is(whitespace, c)) continue\n        if (c === \">\") closeTag(parser)\n        else strictFail(parser, \"Invalid characters in closing tag\")\n      continue\n\n      case S.TEXT_ENTITY:\n      case S.ATTRIB_VALUE_ENTITY_Q:\n      case S.ATTRIB_VALUE_ENTITY_U:\n        switch(parser.state) {\n          case S.TEXT_ENTITY:\n            var returnState = S.TEXT, buffer = \"textNode\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_Q:\n            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = \"attribValue\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = \"attribValue\"\n          break\n        }\n        if (c === \";\") {\n          parser[buffer] += parseEntity(parser)\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n        else if (is(entity, c)) parser.entity += c\n        else {\n          strictFail(parser, \"Invalid character entity\")\n          parser[buffer] += \"&\" + parser.entity + c\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n      continue\n\n      default:\n        throw new Error(parser, \"Unknown state: \" + parser.state)\n    }\n  } // while\n  // cdata blocks can get very big under normal conditions. emit and move on.\n  // if (parser.state === S.CDATA && parser.cdata) {\n  //   emitNode(parser, \"oncdata\", parser.cdata)\n  //   parser.cdata = \"\"\n  // }\n  if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)\n  return parser\n}\n\n/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\nif (!String.fromCodePoint) {\n        (function() {\n                var stringFromCharCode = String.fromCharCode;\n                var floor = Math.floor;\n                var fromCodePoint = function() {\n                        var MAX_SIZE = 0x4000;\n                        var codeUnits = [];\n                        var highSurrogate;\n                        var lowSurrogate;\n                        var index = -1;\n                        var length = arguments.length;\n                        if (!length) {\n                                return '';\n                        }\n                        var result = '';\n                        while (++index < length) {\n                                var codePoint = Number(arguments[index]);\n                                if (\n                                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                                        codePoint < 0 || // not a valid Unicode code point\n                                        codePoint > 0x10FFFF || // not a valid Unicode code point\n                                        floor(codePoint) != codePoint // not an integer\n                                ) {\n                                        throw RangeError('Invalid code point: ' + codePoint);\n                                }\n                                if (codePoint <= 0xFFFF) { // BMP code point\n                                        codeUnits.push(codePoint);\n                                } else { // Astral code point; split in surrogate halves\n                                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                                        codePoint -= 0x10000;\n                                        highSurrogate = (codePoint >> 10) + 0xD800;\n                                        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n                                        codeUnits.push(highSurrogate, lowSurrogate);\n                                }\n                                if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n                                        result += stringFromCharCode.apply(null, codeUnits);\n                                        codeUnits.length = 0;\n                                }\n                        }\n                        return result;\n                };\n                if (Object.defineProperty) {\n                        Object.defineProperty(String, 'fromCodePoint', {\n                                'value': fromCodePoint,\n                                'configurable': true,\n                                'writable': true\n                        });\n                } else {\n                        String.fromCodePoint = fromCodePoint;\n                }\n        }());\n}\n\n})(typeof exports === \"undefined\" ? sax = {} : exports);\n"]},"metadata":{},"sourceType":"script"}